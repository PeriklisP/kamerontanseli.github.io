<!DOCTYPE html>
<html lang="en-gb">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="renderer" content="webkit">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
  <title>Flow Type Checking Tips - Kameron Tanseli</title>
  
  <meta name="description" content="For the past 3 months I have been adding more Flow type checking to a codebase.
Lots of trial and error went into integrating Flow into the existing legacy code and new code. So I will share what I have learnt with you:
Declare types above the component So you have a React.Component and you want to add types to it right? You might be inclined to just add them inline when declaring the component like so:">
  <meta name="author" content="">
  
  <link href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700,700i" rel="stylesheet">
  <link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet">
  <link href="/css/style.css" rel="stylesheet">
  
  <link rel="apple-touch-icon" href="/img/apple-touch-icon.png">
  <link rel="icon" href="/img/favicon.ico">
  
  <meta name="generator" content="Hugo 0.41">
  
  <link rel="alternate" type="application/atom+xml" href="/index.xml" title="Kameron Tanseli">
</head>
<body class="single">
  <header class="header">
    
    <p class="title"><a href="/"><span>üç±</span>Kameron Tanseli</a></p>
    
    <button class="menu-toggle" type="button"></button>
    <nav class="menu">
      <ul>
        
        
      </ul>
    </nav>
  </header>
  <main class="main">

<article class="post post-view">
  <header class="post-header">
    <h1 class="post-title">Flow Type Checking Tips</h1>
    <p class="post-meta">2018.6.10</p>
  </header>
  <div class="post-content">

<p>For the past 3 months I have been adding more Flow type checking to a codebase.</p>

<p>Lots of trial and error went into integrating Flow into the existing legacy code and new code. So I will share what I have learnt with you:</p>

<h2 id="declare-types-above-the-component">Declare types above the component</h2>

<p>So you have a React.Component and you want to add types to it right? You might be inclined to just add them inline when declaring the component like so:</p>

<pre><code class="language-typescript">class Greeting extends React.Component&lt;{ name: string }, void&gt; {
  render() {
    const { name } = this.props;
    return &lt;div&gt;{name}&lt;/div&gt;;
  }
}
</code></pre>

<p>What a joy! You have types for your props, everything is wonderful in the world until‚Ä¶ you need to add some logic to the <code>constructor</code>:</p>

<pre><code class="language-typescript">class Greeting extends React.Component&lt;{ name: string }, void&gt; {
  constructor(props: { name: string }) {
    super(props);
    // some initialisation stuff
  }
  render() {
    const { name } = this.props;
    return &lt;div&gt;{name}&lt;/div&gt;;
  }
}
</code></pre>

<p>Now you have added two declarations of the props for this component. The best way to declare types is to extract it into its own type declaration:</p>

<pre><code class="language-typescript">type GreetingProps = { name: string };

class Greeting extends React.Component&lt;GreetingProps, void&gt; {
  constructor(props: GreetingProps) {
    super(props);
    // some initialisation stuff
  }
  render() {
    const { name } = this.props;
    return &lt;div&gt;{name}&lt;/div&gt;;
  }
}
</code></pre>

<p>The same logic goes for stateless components which take a large number of props like so:</p>

<pre><code class="language-typescript">const ToolbarFilter = ({
  active,
  pending,
  upcoming,
  cancelled,
  recentlyEdited
}: {
  active: boolean;
  pending: boolean;
  upcoming: boolean;
  cancelled: boolean;
  recentlyEdited: boolean;
}) =&gt; &lt;div&gt; {/* Some checkboxes here */} &lt;/div&gt;;
</code></pre>

<p>There is nothing wrong with this approach but it is a lot cleaner to extract it out as well as offering reuse for any parent component above it:</p>

<pre><code class="language-typescript">// this can be used else where
type ToolbarFilters = {
  active: boolean;
  pending: boolean;
  upcoming: boolean;
  cancelled: boolean;
  recentlyEdited: boolean;
};

// needed in case of any new props to be added
type ToolbarFilterProps = ToolbarFilters;

const ToolbarFilter = ({
  active,
  pending,
  upcoming,
  cancelled,
  recentlyEdited
}: ToolbarFilterProps) =&gt; &lt;div&gt; {/* Some checkboxes here */} &lt;/div&gt;;
</code></pre>

<h2 id="extending-types">Extending types</h2>

<p>Like the above example imagine you have a type called <code>ToolbarFilters</code> and it contains all the available options for filtering some data.</p>

<p>Now your component ToolbarFilter uses the <code>ToolbarFilters</code> type in its props. How do we use it? Copy and paste? No. We use <code>&amp;</code> to reuse the type:</p>

<pre><code class="language-typescript">// this can be used else where
type ToolbarFilters = {
  active: boolean,
  pending: boolean,
  upcoming: boolean,
  cancelled: boolean,
  recentlyEdited: boolean
};
// see how we added the new onFilterChange
type ToolbarFilterProps = ToolbarFilters &amp; {
  onFilterChange: ($Keys&lt;ToolbarFilters&gt;, boolean) =&gt; void
};
const ToolbarFilter = ({
  active,
  pending,
  upcoming,
  cancelled,
  recentlyEdited,
  onFilterChange
}: ToolbarFilterProps) =&gt; &lt;div&gt; {/* Some checkboxes here */} &lt;/div&gt;;
</code></pre>

<h2 id="use-react-element-to-avoid-the-issue-of-not-returning-a-component">Use React.Element to avoid the issue of not returning a Component</h2>

<p>We have all been there, where we have written a stateless component and just forgotten to return the JSX:</p>

<pre><code class="language-typescript">const hello = ({ name }: { name: string })=&gt; {
 const fullName: string = name.split(&quot;_&quot;).join(&quot; &quot;);
 (&lt;div&gt;Hello {fullName}&lt;div&gt;);
}
</code></pre>

<p>Then we get the lovely React error to follow it:</p>

<pre><code class="language-markup">A valid React element (or null) must be returned.
You may have returned undefined, an array or some
other invalid object.
</code></pre>

<p>Not so good. But we can catch this before it ever reaches our browser by using <code>React.Element</code>:</p>

<pre><code class="language-typescript">import * as React from 'react';
// this imports all Flow types into the React namespace
const hello = ({ name }: { name: string }): React.Element&lt;'div'&gt; =&gt; {
 const fullName: string = name.split(&quot;_&quot;).join(&quot; &quot;);
 (&lt;div&gt;Hello {fullName}&lt;div&gt;);
}
</code></pre>

<p>Now in this example we get this error:</p>

<pre><code class="language-markup">10: }): React.Element&lt;&quot;div&quot;&gt; =&gt; {
         ^^^^^^^^^^^^^^^^^^^^ undefined. Inexact type is incompatible with exact type
 10: }): React.Element&lt;&quot;div&quot;&gt; =&gt; {
         ^^^^^^^^^^^^^^^^^^^^ exact type: object type
Found 1 error
</code></pre>

<p>There are a lots of other <a href="https://flow.org/en/docs/react/">React Flow types</a> that can be used to add more coverage over a component.</p>

<h2 id="make-use-of-the-utility-types-such-as-keys">Make use of the utility types such as $Keys</h2>

<p>We‚Äôre all in a rush sometimes. So why not learn something that would speed up adding types to our Component. Say we have a component which takes a <code>type</code> prop and returns a component based off that type:</p>

<pre><code class="language-typescript">const Greeting = ({ type }: { type: string }): React.Element&lt;&quot;h2&quot;&gt; =&gt; {
  switch (type) {
    case &quot;welcome&quot;:
      return &lt;h2&gt; Welcome! &lt;/h2&gt;;
    default:
      return &lt;h2&gt; Hello &lt;/h2&gt;;
  }
};
</code></pre>

<p>We would only want this type to ideally be restricted to the choices <code>hello</code> or <code>welcome</code>. That is where <code>$Keys</code> comes in. It scans an Object literal and uses it‚Äôs keys as a string union.</p>

<p>So an object like this: <code>{a: 2, b: 3}</code> is turned into <code>‚Äôa‚Äô | ‚Äòb'</code>.</p>

<p>We can add this type check and refactor:</p>

<pre><code class="language-typescript">const greetingComponents = {
  welcome: () =&gt; &lt;h2&gt; Welcome! &lt;/h2&gt;,
  hello: () =&gt; &lt;h2&gt; Hello &lt;/h2&gt;
};
type GreetingProps = {
  type: $Keys&lt;typeof greetingComponents&gt;;
};
const Greeting = ({ type }: GreetingProps): React.Element&lt;&quot;h2&quot;&gt; =&gt;
  greetingComponents[type]();
</code></pre>

<p>If we tried to use the key <code>bye</code> for example it will throw the rather nice error:</p>

<pre><code class="language-markup">15: &lt;Greeting type='bye' /&gt;
                     ^ property `bye`. Property not found in
7:  type: $Keys&lt;typeof greetingComponents&gt;
          ^ object literal
</code></pre>

<p>Flow offers a bunch of really useful utility types that you can read about <a href="https://flow.org/en/docs/types/utilities/#toc-keys">here</a>.</p>

<h2 id="move-all-reused-types-to-a-separate-file">Move all reused types to a separate file</h2>

<p>You may notice as you build out your React app that a certain type is used in multiple places. You may decide to just import the type from that one component: <code>import type {State} from ‚Äò../some/component‚Äô</code> .</p>

<p>But this will slowly get out of hand.</p>

<p>My suggestion is to create a <code>types.js</code> file in the root of your app to keep reference .</p>

<p>This file should contain:</p>

<ul>
<li>Only app wide shared types (if its feature wide then create another types.js inside that feature folder).</li>
<li>Redux types like the InitialState for reducers etc.</li>
<li>Only flow types.</li>
</ul>

<h2 id="if-you-want-an-object-to-be-immutable-then-you-can-type-check-it">If you want an object to be immutable then you can type check it</h2>

<p>You really don‚Äôt want some component messing around with your state. So why not protect against it by declaring that object as immutable:</p>

<pre><code class="language-typescript">type AppConfig = {
 +apiKey: string // the '+' makes it immutable in Flow
};
const Settings: AppConfig = {
 apiKey: 'rihfwefiweufweiufgewfugew84r34t3'
};
// later on....
Settings.apiKey = 'fiohwefoihefoihfoeihfewifhwfihefhwoef';
</code></pre>

<p>Flow helps protect against the change by throwing this error:</p>

<pre><code class="language-markup">11: Settings.apiKey = 'fiohwefoihefoihfoeihfewifhwfihefhwoef';
    ^ object type. Covariant property `apiKey` incompatible with contravariant use in
11: Settings.apiKey = 'fiohwefoihefoihfoeihfewifhwfihefhwoef';
    ^ assignment of property `apiKey`
</code></pre>

<h2 id="read-the-documentation-find-references">Read the documentation &amp; find references</h2>

<p>I can‚Äôt stress this enough how detailed the Flow docs are at explaining things. The most useful links I have found are as follows:</p>

<ol>
<li><a href="https://flow.org/en/docs/react/components/">Components | Flow</a></li>
<li><a href="https://flow.org/en/docs/react/redux/">Redux | Flow</a></li>
<li><a href="https://flow.org/en/docs/react/children/">Children | Flow</a></li>
<li><a href="https://flow.org/en/docs/lang/refinements/">Type Refinements | Flow</a></li>
<li><a href="https://www.saltycrane.com/flow-type-cheat-sheet/latest/#lib/dom.js">Flow DOM cheat sheet</a></li>
</ol>
</div>
  <footer class="post-footer">
    
  </footer>
  
  
  
  
</article>
</main>
<footer class="footer">
  <span>&copy; 2017-2018 Kameron Tanseli üéâ</span>
  <span>&middot;</span>
  <span>Powered by <a href="https://gohugo.io/" target="_blank">Hugo‚ù§Ô∏èÔ∏è</a></span>
  <span>&middot;</span>
  <span>Designed by <a href="http://21beats.com/" target="_blank">Ô∏è21beats‚ö°Ô∏è</a></span>
</footer>
<script src="https://cdn.bootcss.com/instantclick/3.0.1/instantclick.min.js" data-no-instant></script>
<script data-no-instant>InstantClick.init();</script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js" data-no-instant></script>
<script data-no-instant>
  hljs.initHighlightingOnLoad();
  menuToggle();
  InstantClick.on('change', function() {
    var blocks = document.querySelectorAll('pre code');
    for (var i = 0; i < blocks.length; i++) {
      hljs.highlightBlock(blocks[i]);
    }
    menuToggle();
  });
  function menuToggle() {
    var $toggle = document.querySelector('.menu-toggle');
    if (!$toggle.offsetParent) {
      return;
    }
    var $body = document.querySelector('body');
    $toggle.addEventListener('click', function() {
      $body.classList.toggle('noscroll');
    }, false);
  }
</script>
</body>
</html>

