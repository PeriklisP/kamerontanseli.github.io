<!DOCTYPE html>
<html lang="en-gb">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="renderer" content="webkit">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
  <title>Use render props to separate logic from presentation - Kameron Tanseli</title>
  
  <meta name="description" content="Separating logic from your presentation has always been a best practise. It enforces the single responsibility principle (SRP) and makes the feature easier to test.
React gets in trouble for letting developers mush the two concerns together with ease. Lets take an example from the homepage to explain:
class Timer extends React.Component { constructor(props) { super(props) this.state = { seconds: 0 } } tick() { this.setState(prevState =&gt; ({ seconds: prevState.">
  <meta name="author" content="">
  
  <link href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700,700i" rel="stylesheet">
  <link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet">
  <link href="/css/style.css" rel="stylesheet">
  
  <link rel="apple-touch-icon" href="/img/apple-touch-icon.png">
  <link rel="icon" href="/img/favicon.ico">
  
  <meta name="generator" content="Hugo 0.41">
  
  <link rel="alternate" type="application/atom+xml" href="/index.xml" title="Kameron Tanseli">
</head>
<body class="single">
  <header class="header">
    
    <p class="title"><a href="/"><span>üç±</span>Kameron Tanseli</a></p>
    
    <button class="menu-toggle" type="button"></button>
    <nav class="menu">
      <ul>
        
        
      </ul>
    </nav>
  </header>
  <main class="main">

<style media="screen">
  pre {
    overflow: auto;
  }
</style>
<article class="post post-view">
  <header class="post-header">
    <h1 class="post-title">Use render props to separate logic from presentation</h1>
    <p class="post-meta">2018.6.10</p>
  </header>
  <div class="post-content">

<p>Separating logic from your presentation has always been a best practise. It
enforces the <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle">single responsibility principle (SRP)</a> and makes the feature easier
to test.</p>

<p>React gets in trouble for letting developers mush the two concerns together with ease.
Lets take an example from the <a href="https://reactjs.org/">homepage</a> to explain:</p>

<pre><code class="language-html">class Timer extends React.Component {
  constructor(props) {
    super(props)
    this.state = { seconds: 0 }
  }

  tick() {
    this.setState(prevState =&gt; ({ seconds: prevState.seconds + 1 }))
  }

  componentDidMount() {
    this.interval = setInterval(() =&gt; this.tick(), 1000)
  }

  componentWillUnmount() {
    clearInterval(this.interval)
  }

  render() {
    return &lt;div&gt;Seconds: {this.state.seconds}&lt;/div&gt;
  }
}
</code></pre>

<p>Above you can see the rather simple <code>Timer</code> class. You can also see the
display logic for the class is coded right into the <code>render()</code> method.</p>

<p>The problem with having <code>&lt;div&gt;Seconds: {this.state.seconds}&lt;/div&gt;</code> in the <code>Timer</code>
class is that it&rsquo;s not separating logic from state.</p>

<p>Lets separate the two concerns:</p>

<pre><code class="language-html">
const SecondsActive = ({ seconds }) =&gt; &lt;div&gt;Seconds: {seconds}&lt;/div&gt;;

class TimerContainer extends React.Component {
  state = { seconds: 0 }

  tick() {
    this.setState(({ seconds }) =&gt; ({ seconds: seconds + 1 }))
  }

  componentDidMount() {
    this.interval = setInterval(() =&gt; this.tick(), 1000)
  }

  componentWillUnmount() {
    clearInterval(this.interval)
  }

  render() {
    return this.props.view({ seconds: this.state.seconds })
  }
}

ReactDOM.render(
  &lt;TimerContainer view={SecondsActive} /&gt;,
  document.getElementById('app')
);
</code></pre>

<p>With a simple switch to rendering via a <code>prop</code> we have made the <code>Timer</code>
(<code>TimerContainer</code>) class reusable across many presentational components and have
made the presentational component super easy to test!</p>

<h3 id="read-more-about-render-props-and-react">Read more about render props and React</h3>

<ul>
<li><a href="https://gist.github.com/chantastic/fc9e3853464dffdb1e3c">JSX, a year in</a></li>
<li><a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0">Presentational and Container Components</a></li>
<li><a href="https://reactjs.org/">React JS</a></li>
<li><a href="https://reactpatterns.com/#render-callback">Render Props</a></li>
</ul>
</div>
  <footer class="post-footer">
    
  </footer>
  
  
  
  
</article>
</main>
<footer class="footer">
  <span>&copy; 2017-2018 Kameron Tanseli üéâ</span>
  <span>&middot;</span>
  <span>Powered by <a href="https://gohugo.io/" target="_blank">Hugo‚ù§Ô∏èÔ∏è</a></span>
  <span>&middot;</span>
  <span>Designed by <a href="http://21beats.com/" target="_blank">Ô∏è21beats‚ö°Ô∏è</a></span>
</footer>
<script src="https://cdn.bootcss.com/instantclick/3.0.1/instantclick.min.js" data-no-instant></script>
<script data-no-instant>InstantClick.init();</script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js" data-no-instant></script>
<script data-no-instant>
  hljs.initHighlightingOnLoad();
  menuToggle();
  InstantClick.on('change', function() {
    var blocks = document.querySelectorAll('pre code');
    for (var i = 0; i < blocks.length; i++) {
      hljs.highlightBlock(blocks[i]);
    }
    menuToggle();
  });
  function menuToggle() {
    var $toggle = document.querySelector('.menu-toggle');
    if (!$toggle.offsetParent) {
      return;
    }
    var $body = document.querySelector('body');
    $toggle.addEventListener('click', function() {
      $body.classList.toggle('noscroll');
    }, false);
  }
</script>
</body>
</html>

