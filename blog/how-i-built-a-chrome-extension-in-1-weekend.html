<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width, initial-scale=1" class="jsx-2075253673 next-head"/><meta charSet="utf-8" class="jsx-2075253673 next-head"/><title class="jsx-2075253673 next-head">Chrome Extensions (How to Build &amp; Monetise)</title><meta name="description" content="I made a very conscious decision early on to try writing the initial MVP without a framework. I wanted the end result to be small." class="jsx-2075253673 next-head"/><meta name="twitter:card" content="summary" class="jsx-2075253673 next-head"/><meta name="twitter:site" content="@KameronTanseli" class="jsx-2075253673 next-head"/><meta name="twitter:title" content="Chrome Extensions (How to Build &amp; Monetise)" class="jsx-2075253673 next-head"/><meta name="twitter:description" content="I made a very conscious decision early on to try writing the initial MVP without a framework. I wanted the end result to be small." class="jsx-2075253673 next-head"/><meta name="twitter:creator" content="@KameronTanseli" class="jsx-2075253673 next-head"/><meta name="twitter:image" content="https://kamrn.com/static/meta.png" class="jsx-2075253673 next-head"/><meta property="og:title" content="Chrome Extensions (How to Build &amp; Monetise)" class="jsx-2075253673 next-head"/><meta property="og:type" content="article" class="jsx-2075253673 next-head"/><meta property="og:url" content="https://kamrn.com" class="jsx-2075253673 next-head"/><meta property="og:image" content="https://kamrn.com/static/meta.png" class="jsx-2075253673 next-head"/><meta property="og:description" content="I made a very conscious decision early on to try writing the initial MVP without a framework. I wanted the end result to be small." class="jsx-2075253673 next-head"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-72466279-4" class="jsx-2075253673 next-head"></script><link rel="preload" href="/_next/static/sH7wYPE0PVVjvK5hrNNaU/pages/blog/[slug].js" as="script"/><link rel="preload" href="/_next/static/sH7wYPE0PVVjvK5hrNNaU/pages/_app.js" as="script"/><link rel="preload" href="/_next/static/runtime/webpack-ec75628763f128f9ddee.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.fb2d51f5ea79888db098.js" as="script"/><link rel="preload" href="/_next/static/runtime/main-606693b16ac3d77701fe.js" as="script"/><style id="__jsx-2075253673">*{box-sizing:border-box;}html{font-size:100%;}body{background-color:#fff;font-weight:400;font-family:Helvetica;line-height:1.75;color:#000;margin:0;padding:0;}.container{max-width:800px;margin:0 auto;}</style><style id="__jsx-1866064296">.navigation-bg.jsx-1866064296{background-color:#3286b3;}.navigation.jsx-1866064296{padding:1em 2em;display:grid;grid-template-columns:1fr auto;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}.navigation-menu.jsx-1866064296{display:grid;grid-template-columns:repeat(4,1fr);grid-gap:20px;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;text-align:center;}.navigation-logo.jsx-1866064296{-webkit-text-decoration:none;text-decoration:none;color:#fff;font-size:1em;-webkit-letter-spacing:5px;-moz-letter-spacing:5px;-ms-letter-spacing:5px;letter-spacing:5px;}.navigation-link.jsx-1866064296{color:#fff;-webkit-text-decoration:none;text-decoration:none;font-size:0.9em;}@media screen and (max-width:480px){.navigation.jsx-1866064296{grid-template-columns:1fr;grid-gap:10px;}.navigation-menu.jsx-1866064296{text-align:left;grid-template-columns:repeat(4,auto);}}</style><style id="__jsx-525169924">ul.jsx-525169924{display:grid;grid-template-columns:repeat(5,auto);list-style:none;margin:0;padding:1em;}li.jsx-525169924{font-size:0.8em;}a.jsx-525169924{color:#0073a7;}@media screen and (max-width:480px){ul.jsx-525169924{grid-template-columns:repeat(2,auto);}}</style><style id="__jsx-1922407009">.content.jsx-1922407009{padding:2em;}.content-title.jsx-1922407009{margin-top:0;margin-bottom:1em;}.content.jsx-1922407009 blockquote{background-color:#eee;padding:0.5em;margin:0;padding-left:1em;border-left:5px solid grey;}.content.jsx-1922407009 blockquote > p{margin:0;}.content.jsx-1922407009 a{color:#0073a7;}.content.jsx-1922407009 img{max-width:100%;margin:0 auto;display:block;}.content.jsx-1922407009 pre{padding:1em;background-color:#eee;border-radius:4px;}</style></head><body><div id="__next"><div class="jsx-1866064296 navigation-bg"><div class="jsx-1866064296 container"><div class="jsx-1866064296 navigation"><div class="jsx-1866064296 navigation-brand"><a href="/" class="jsx-1866064296 navigation-logo">KAMRN</a></div><div class="jsx-1866064296 navigation-menu"><div class="jsx-1866064296"><a href="/" class="jsx-1866064296 navigation-link">Home</a></div><div class="jsx-1866064296"><a href="/about" class="jsx-1866064296 navigation-link">About</a></div><div class="jsx-1866064296"><a href="/projects" class="jsx-1866064296 navigation-link">Projects</a></div><div class="jsx-1866064296"><a target="_blank" href="https://kameront.substack.com" class="jsx-1866064296 navigation-link">Newsletter</a></div></div></div></div></div><div class="jsx-1922407009 container"><div class="jsx-1922407009 content"><article class="jsx-1922407009"><h1 class="jsx-1922407009 content-title">Chrome Extensions (How to Build &amp; Monetise)</h1><h3>Starting Off Light</h3><p>Much like how we have <a href="https://reactjs.org/docs/create-a-new-react-app.html">Create React App</a> for building front end applications, we also have the <a href="https://github.com/dutiyesh/chrome-extension-cli">Chrome Extension CLI</a> for quickly spinning up Chrome Extensions. This saved me hours of setting up Webpack and configuring manifests and I highly recommend you use it!</p><p>I made a very conscious decision early on to try writing the initial MVP without a framework. I wanted the end result to be small in size as my users would be downloading the entire extension before using it.</p><pre><code class="language-js">const isDev = process.env.NODE_ENV === &quot;development&quot;;

let state = {
  license: {
    activated: false,
  },
  activation: {
    error: false,
  },
  currentTab: &quot;validations&quot;,
  validations: {
    config: {
      twitter: true,
    },
    passed: [],
    failed: [],
    siteInfo: {},
  },
};

export function reducer(action = {}, state = {}) {
  switch (action.type) {
    case &quot;ACTIVATION_FAILURE&quot;:
      state.activation.error = true;
      return state;
    case &quot;LICENSE_VALID&quot;:
      state.activation.error = false;
      state.license.activated = true;
      return state;
    case &quot;NAVIGATION&quot;:
      state.currentTab = action.payload.currentTab;
      return state;
    case &quot;VALIDATION_SET&quot;: {
      state.validations.passed = action.payload.passed;
      state.validations.failed = action.payload.failed;
      state.validations.siteInfo = action.payload.siteInfo;
      return state;
    }
    case &quot;VALIDATION_TWITTER_CHANGE&quot;: {
      state.validations.config.twitter = action.payload.twitter;
      return state;
    }
    default:
      return state;
  }
}

export const dispatch = (callback) =&gt; (action) =&gt; {
  const oldState = JSON.parse(JSON.stringify(state));
  if (isDev) console.log(&quot;Previous State&quot;, oldState);
  state = reducer(action, oldState);
  if (isDev) console.log(&quot;New State&quot;, state);
  callback(state);
};</code></pre><p>It was quite simple to hook this up with my LitHTML views:</p><pre><code class="language-js">const emit = dispatch((state) =&gt;
  render(app(state, emit), document.getElementById(&quot;app&quot;))
);</code></pre><h3>Dealing with Communication</h3><p>I wasted 1-2 hours on trying to figure out how to pass information from my content script (a script that executes code on the user’s current tab) to my extension popup.</p><p>Turns out that in order to communicate with the content script you need to first fetch the Tab ID:</p><p><code>contentScript.js</code></p><pre><code class="language-js">chrome.runtime.onMessage.addListener((request, sender, sendResponse) =&gt; {
  switch (request.type) {
    case &quot;FETCH_META_DATA&quot;: {
      sendResponse({
        ...validateMetaData(),
        siteInfo: getSiteInfo(),
      });
      break;
    }
    case &quot;ERROR&quot;: {
      console.error(request.payload);
      break;
    }
    default:
      break;
  }
});</code></pre><p><code>popup.js</code></p><pre><code class="language-js">chrome.tabs.getSelected(null, (tab) =&gt; {
  chrome.tabs.sendMessage(
    tab.id,
    { type: &quot;FETCH_META_DATA&quot; },
    (response) =&gt; {}
  );
});</code></pre><h3>Monetisation &amp; Distribution</h3><p>Now that the UI and Business Logic was sorted I needed to find a way to monetize my creation. Taking inspiration from CSS Scan I opted to host my extension on Gumroad.</p><p>I could have gone the route of uploading my extension to the Chrome Web Store. However, as the extension is essentially useless without a License Key I would have failed the Extension Review.</p><p>Instead, the extension build is uploaded as a zip to GumRoad. It’s quite a simple process to add the extension to Chrome and as my customers were developers I didn’t think the extra step of unzipping and adding via chrome://extensions was that difficult.</p><p>Fortunately, GumRoad has an inbuilt License Key API.</p><p>Unfortunately, it requires a server to call it, so I had to add to build a small web service to call from my extension.</p><p>Note: The API only accepts URL encoded requests and not JSON (this will save you 30 minutes of wondering why it doesn’t work):</p><pre><code class="language-js">const result = await axios({
  url: `https://api.gumroad.com/v2/licenses/verify`,
  method: &quot;POST&quot;,
  headers: { &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot; },
  data: `product_permalink=&lt;permalink&gt;&amp;license_key=${
    encodeURIComponent(license_key)
  }`,
});</code></pre><iframe src="https://kameront.substack.com/embed" width="100%" height="320" style="border:0" frameBorder="0" scrolling="no" class="jsx-1922407009"></iframe></article></div></div><footer class="jsx-525169924 container"><ul class="jsx-525169924"><li style="color:rgb(161 161 161)" class="jsx-525169924">© Kameron Tanseli 2020</li><li class="jsx-525169924"><a target="_blank" rel="noopener noreferrer" href="https://www.instagram.com/kameron_tanseli" class="jsx-525169924">Instagram</a></li><li class="jsx-525169924"><a target="_blank" rel="noopener noreferrer" href="https://twitter.com/KameronTanseli" class="jsx-525169924">Twitter</a></li><li class="jsx-525169924"><a target="_blank" rel="noopener noreferrer" href="mailto:kamerontanseliwork@gmail.com" class="jsx-525169924">Email</a></li><li class="jsx-525169924"><a target="_blank" rel="noopener noreferrer" href="https://kameront.substack.com/" class="jsx-525169924">Newsletter</a></li></ul></footer></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{"post":{"content":"\n### Starting Off Light\n\nMuch like how we have [Create React App](https://reactjs.org/docs/create-a-new-react-app.html) for building front end applications, we also have the [Chrome Extension CLI](https://github.com/dutiyesh/chrome-extension-cli) for quickly spinning up Chrome Extensions. This saved me hours of setting up Webpack and configuring manifests and I highly recommend you use it!\n\nI made a very conscious decision early on to try writing the initial MVP without a framework. I wanted the end result to be small in size as my users would be downloading the entire extension before using it.\n\n```js\nconst isDev = process.env.NODE_ENV === \"development\";\n\nlet state = {\n  license: {\n    activated: false,\n  },\n  activation: {\n    error: false,\n  },\n  currentTab: \"validations\",\n  validations: {\n    config: {\n      twitter: true,\n    },\n    passed: [],\n    failed: [],\n    siteInfo: {},\n  },\n};\n\nexport function reducer(action = {}, state = {}) {\n  switch (action.type) {\n    case \"ACTIVATION_FAILURE\":\n      state.activation.error = true;\n      return state;\n    case \"LICENSE_VALID\":\n      state.activation.error = false;\n      state.license.activated = true;\n      return state;\n    case \"NAVIGATION\":\n      state.currentTab = action.payload.currentTab;\n      return state;\n    case \"VALIDATION_SET\": {\n      state.validations.passed = action.payload.passed;\n      state.validations.failed = action.payload.failed;\n      state.validations.siteInfo = action.payload.siteInfo;\n      return state;\n    }\n    case \"VALIDATION_TWITTER_CHANGE\": {\n      state.validations.config.twitter = action.payload.twitter;\n      return state;\n    }\n    default:\n      return state;\n  }\n}\n\nexport const dispatch = (callback) =\u003e (action) =\u003e {\n  const oldState = JSON.parse(JSON.stringify(state));\n  if (isDev) console.log(\"Previous State\", oldState);\n  state = reducer(action, oldState);\n  if (isDev) console.log(\"New State\", state);\n  callback(state);\n};\n```\n\nIt was quite simple to hook this up with my LitHTML views:\n\n```js\nconst emit = dispatch((state) =\u003e\n  render(app(state, emit), document.getElementById(\"app\"))\n);\n```\n\n### Dealing with Communication\n\nI wasted 1-2 hours on trying to figure out how to pass information from my content script (a script that executes code on the user’s current tab) to my extension popup.\n\nTurns out that in order to communicate with the content script you need to first fetch the Tab ID:\n\n`contentScript.js`\n\n```js\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) =\u003e {\n  switch (request.type) {\n    case \"FETCH_META_DATA\": {\n      sendResponse({\n        ...validateMetaData(),\n        siteInfo: getSiteInfo(),\n      });\n      break;\n    }\n    case \"ERROR\": {\n      console.error(request.payload);\n      break;\n    }\n    default:\n      break;\n  }\n});\n```\n\n`popup.js`\n\n```js\nchrome.tabs.getSelected(null, (tab) =\u003e {\n  chrome.tabs.sendMessage(\n    tab.id,\n    { type: \"FETCH_META_DATA\" },\n    (response) =\u003e {}\n  );\n});\n```\n\n### Monetisation \u0026 Distribution\n\nNow that the UI and Business Logic was sorted I needed to find a way to monetize my creation. Taking inspiration from CSS Scan I opted to host my extension on Gumroad.\n\nI could have gone the route of uploading my extension to the Chrome Web Store. However, as the extension is essentially useless without a License Key I would have failed the Extension Review.\n\nInstead, the extension build is uploaded as a zip to GumRoad. It’s quite a simple process to add the extension to Chrome and as my customers were developers I didn’t think the extra step of unzipping and adding via chrome://extensions was that difficult.\n\nFortunately, GumRoad has an inbuilt License Key API.\n\nUnfortunately, it requires a server to call it, so I had to add to build a small web service to call from my extension.\n\nNote: The API only accepts URL encoded requests and not JSON (this will save you 30 minutes of wondering why it doesn’t work):\n\n```js\nconst result = await axios({\n  url: `https://api.gumroad.com/v2/licenses/verify`,\n  method: \"POST\",\n  headers: { \"Content-Type\": \"application/x-www-form-urlencoded\" },\n  data: `product_permalink=\u003cpermalink\u003e\u0026license_key=${\n    encodeURIComponent(license_key)\n  }`,\n});\n```","data":{"author":"Kameron Tanseli","date":"2020-09-24T16:24:35.794Z","hero_image":"https://ucarecdn.com/81ef33ca-1950-40fe-bcaf-ba09f1f81e9a/validations---previews.png","title":"Chrome Extensions (How to Build \u0026 Monetise)","byline":"I made a very conscious decision early on to try writing the initial MVP without a framework. I wanted the end result to be small."},"isEmpty":false,"excerpt":""},"slug":"how-i-built-a-chrome-extension-in-1-weekend"}},"page":"/blog/[slug]","query":{"slug":"how-i-built-a-chrome-extension-in-1-weekend"},"buildId":"sH7wYPE0PVVjvK5hrNNaU","dynamicBuildId":false,"nextExport":true}</script><script async="" id="__NEXT_PAGE__/blog/[slug]" src="/_next/static/sH7wYPE0PVVjvK5hrNNaU/pages/blog/[slug].js"></script><script async="" id="__NEXT_PAGE__/_app" src="/_next/static/sH7wYPE0PVVjvK5hrNNaU/pages/_app.js"></script><script src="/_next/static/runtime/webpack-ec75628763f128f9ddee.js" async=""></script><script src="/_next/static/chunks/commons.fb2d51f5ea79888db098.js" async=""></script><script src="/_next/static/runtime/main-606693b16ac3d77701fe.js" async=""></script></body></html>