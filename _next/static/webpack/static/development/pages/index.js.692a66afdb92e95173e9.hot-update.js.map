{"version":3,"file":"static/webpack/static/development/pages/index.js.692a66afdb92e95173e9.hot-update.js","sources":["webpack:///./posts sync \\.md$","webpack:///./posts/utilise-render-props-to-separate-logic-from-presentation-in-react.md"],"sourcesContent":["var map = {\n\t\"./9-ways-to-level-up-your-javascript-code.md\": \"./posts/9-ways-to-level-up-your-javascript-code.md\",\n\t\"./quick-guide-to-using-interfaces-with-javascript.md\": \"./posts/quick-guide-to-using-interfaces-with-javascript.md\",\n\t\"./the-rules-of-reusable-components.md\": \"./posts/the-rules-of-reusable-components.md\",\n\t\"./utilise-render-props-to-separate-logic-from-presentation-in-react.md\": \"./posts/utilise-render-props-to-separate-logic-from-presentation-in-react.md\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./posts sync recursive \\\\.md$\";","export default \"# Utilise render props to separate logic from presentation in React\\n\\nSeparating logic from your presentation has always been a best practise. It enforces the [single responsibility principle (SRP)](https://en.wikipedia.org/wiki/Single_responsibility_principle) and makes the code easier to test.\\n\\nReact however gets in trouble for letting developers mush the two concerns together with ease. Lets take an example from the [homepage](https://reactjs.org/) to explain:\\n\\n```javascript\\nclass Timer extends React.Component {\\n  constructor(props) {\\n    super(props);\\n    this.state = { seconds: 0 };\\n  }\\n  tick() {\\n    this.setState(prevState => ({ seconds: prevState.seconds + 1 }));\\n  }\\n  componentDidMount() {\\n    this.interval = setInterval(() => this.tick(), 1000);\\n  }\\n  componentWillUnmount() {\\n    clearInterval(this.interval);\\n  }\\n  render() {\\n    return <div>Seconds: {this.state.seconds}</div>;\\n  }\\n}\\n```\\n\\nAbove you can see the rather simple Timer class. You can also see the display logic for the class is coded right into the `render()` method.\\n\\nThe problem with having `<div>Seconds: {this.state.seconds}</div>` in the `Timer` class is that itâ€™s not separating logic from presentation.\\n\\nLets separate the two concerns:\\n\\n```javascript\\nconst SecondsActive = ({ seconds }) => <div>Seconds: {seconds}</div>;\\n\\nclass TimerContainer extends React.Component {\\n  state = { seconds: 0 };\\n  tick() {\\n    this.setState(({ seconds }) => ({ seconds: seconds + 1 }));\\n  }\\n  componentDidMount() {\\n    this.interval = setInterval(() => this.tick(), 1000);\\n  }\\n  componentWillUnmount() {\\n    clearInterval(this.interval);\\n  }\\n  render() {\\n    return this.props.view({ seconds: this.state.seconds });\\n  }\\n}\\n\\nReactDOM.render(\\n  <TimerContainer view={SecondsActive} />,\\n  document.getElementById(\\\"app\\\")\\n);\\n```\\n\\nWith a simple switch to rendering via a prop we have made the `Timer` class reusable across many presentational components and have made the presentational component super easy to test!\""],"mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzBA;AAAA;;;;A","sourceRoot":""}