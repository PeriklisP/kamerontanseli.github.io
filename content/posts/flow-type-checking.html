<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <link href="https://fonts.googleapis.com/css?family=Work+Sans" rel="stylesheet">
  <link rel="stylesheet" href="/scss/main.css">
   
    <link rel="stylesheet" href="/scss/vendor/prism.css">
  
</head>
<body>
  <header class="container">
    <nav class="navbar">
  <ul class="navbar__list">
    <li class="navbar__list-item navbar__list-item--brand">
      <a class="navbar__list-link" href="/">Kameron Tanseli</a>
    </li>
  </ul>
</nav>
     
      <section class="hero">
  <h1 class="hero__title">flow-type-checking</h1>
</section>
    
  </header>
  <main class="container">
    <p>For the past 3 months I have been adding more Flow type checking to a codebase.</p>
<p>Lots of trial and error went into integrating Flow into the existing legacy code and new code. So I will share what I have learnt with you:</p>
<h2>Declare types above the component</h2><p>So you have a React.Component and you want to add types to it right? You might be inclined to just add them inline when declaring the component like so:</p>
<pre><code class="language-typescript">class Greeting extends React.Component&lt;{ name: string }, void&gt; {
  render() {
    const { name } = this.props;
    return &lt;div&gt;{name}&lt;/div&gt;;
  }
}</code></pre>
<p>What a joy! You have types for your props, everything is wonderful in the world until… you need to add some logic to the <code>constructor</code>:</p>
<pre><code class="language-typescript">class Greeting extends React.Component&lt;{ name: string }, void&gt; {
  constructor(props: { name: string }) {
    super(props);
    // some initialisation stuff
  }
  render() {
    const { name } = this.props;
    return &lt;div&gt;{name}&lt;/div&gt;;
  }
}</code></pre>
<p>Now you have added two declarations of the props for this component. The best way to declare types is to extract it into its own type declaration:</p>
<pre><code class="language-typescript">type GreetingProps = { name: string };

class Greeting extends React.Component&lt;GreetingProps, void&gt; {
  constructor(props: GreetingProps) {
    super(props);
    // some initialisation stuff
  }
  render() {
    const { name } = this.props;
    return &lt;div&gt;{name}&lt;/div&gt;;
  }
}</code></pre>
<p>The same logic goes for stateless components which take a large number of props like so:</p>
<pre><code class="language-typescript">const ToolbarFilter = ({
  active,
  pending,
  upcoming,
  cancelled,
  recentlyEdited
}: {
  active: boolean;
  pending: boolean;
  upcoming: boolean;
  cancelled: boolean;
  recentlyEdited: boolean;
}) =&gt; &lt;div&gt; {/* Some checkboxes here */} &lt;/div&gt;;</code></pre>
<p>There is nothing wrong with this approach but it is a lot cleaner to extract it out as well as offering reuse for any parent component above it:</p>
<pre><code class="language-typescript">// this can be used else where
type ToolbarFilters = {
  active: boolean;
  pending: boolean;
  upcoming: boolean;
  cancelled: boolean;
  recentlyEdited: boolean;
};

// needed in case of any new props to be added
type ToolbarFilterProps = ToolbarFilters;

const ToolbarFilter = ({
  active,
  pending,
  upcoming,
  cancelled,
  recentlyEdited
}: ToolbarFilterProps) =&gt; &lt;div&gt; {/* Some checkboxes here */} &lt;/div&gt;;</code></pre>
<h2>Extending types</h2><p>Like the above example imagine you have a type called <code>ToolbarFilters</code> and it contains all the available options for filtering some data.</p>
<p>Now your component ToolbarFilter uses the <code>ToolbarFilters</code> type in its props. How do we use it? Copy and paste? No. We use <code>&amp;</code> to reuse the type:</p>
<pre><code class="language-typescript">// this can be used else where
type ToolbarFilters = {
  active: boolean,
  pending: boolean,
  upcoming: boolean,
  cancelled: boolean,
  recentlyEdited: boolean
};
// see how we added the new onFilterChange
type ToolbarFilterProps = ToolbarFilters &amp; {
  onFilterChange: ($Keys&lt;ToolbarFilters&gt;, boolean) =&gt; void
};
const ToolbarFilter = ({
  active,
  pending,
  upcoming,
  cancelled,
  recentlyEdited,
  onFilterChange
}: ToolbarFilterProps) =&gt; &lt;div&gt; {/* Some checkboxes here */} &lt;/div&gt;;</code></pre>
<h2>Use React.Element to avoid the issue of not returning a Component</h2><p>We have all been there, where we have written a stateless component and just forgotten to return the JSX:</p>
<pre><code class="language-typescript">const hello = ({ name }: { name: string })=&gt; {
 const fullName: string = name.split(&quot;_&quot;).join(&quot; &quot;);
 (&lt;div&gt;Hello {fullName}&lt;div&gt;);
}</code></pre>
<p>Then we get the lovely React error to follow it:</p>
<pre><code class="language-markup">A valid React element (or null) must be returned.
You may have returned undefined, an array or some
other invalid object.</code></pre>
<p>Not so good. But we can catch this before it ever reaches our browser by using <code>React.Element</code>:</p>
<pre><code class="language-typescript">import * as React from &#39;react&#39;;
// this imports all Flow types into the React namespace
const hello = ({ name }: { name: string }): React.Element&lt;&#39;div&#39;&gt; =&gt; {
 const fullName: string = name.split(&quot;_&quot;).join(&quot; &quot;);
 (&lt;div&gt;Hello {fullName}&lt;div&gt;);
}</code></pre>
<p>Now in this example we get this error:</p>
<pre><code class="language-markup">10: }): React.Element&lt;&quot;div&quot;&gt; =&gt; {
         ^^^^^^^^^^^^^^^^^^^^ undefined. Inexact type is incompatible with exact type
 10: }): React.Element&lt;&quot;div&quot;&gt; =&gt; {
         ^^^^^^^^^^^^^^^^^^^^ exact type: object type
Found 1 error</code></pre>
<p>There are a lots of other <a href="https://flow.org/en/docs/react/">React Flow types</a> that can be used to add more coverage over a component.</p>
<h2>Make use of the utility types such as $Keys</h2><p>We’re all in a rush sometimes. So why not learn something that would speed up adding types to our Component. Say we have a component which takes a <code>type</code> prop and returns a component based off that type:</p>
<pre><code class="language-typescript">const Greeting = ({ type }: { type: string }): React.Element&lt;&quot;h2&quot;&gt; =&gt; {
  switch (type) {
    case &quot;welcome&quot;:
      return &lt;h2&gt; Welcome! &lt;/h2&gt;;
    default:
      return &lt;h2&gt; Hello &lt;/h2&gt;;
  }
};</code></pre>
<p>We would only want this type to ideally be restricted to the choices <code>hello</code> or <code>welcome</code>. That is where <code>$Keys</code> comes in. It scans an Object literal and uses it’s keys as a string union.</p>
<p>So an object like this: <code>{a: 2, b: 3}</code> is turned into <code>’a’ | ‘b&#39;</code>.</p>
<p>We can add this type check and refactor:</p>
<pre><code class="language-typescript">const greetingComponents = {
  welcome: () =&gt; &lt;h2&gt; Welcome! &lt;/h2&gt;,
  hello: () =&gt; &lt;h2&gt; Hello &lt;/h2&gt;
};
type GreetingProps = {
  type: $Keys&lt;typeof greetingComponents&gt;;
};
const Greeting = ({ type }: GreetingProps): React.Element&lt;&quot;h2&quot;&gt; =&gt;
  greetingComponents[type]();</code></pre>
<p>If we tried to use the key <code>bye</code> for example it will throw the rather nice error:</p>
<pre><code class="language-markup">15: &lt;Greeting type=&#39;bye&#39; /&gt;
                     ^ property `bye`. Property not found in
7:  type: $Keys&lt;typeof greetingComponents&gt;
          ^ object literal</code></pre>
<p>Flow offers a bunch of really useful utility types that you can read about <a href="https://flow.org/en/docs/types/utilities/#toc-keys">here</a>.</p>
<h2>Move all reused types to a separate file</h2><p>You may notice as you build out your React app that a certain type is used in multiple places. You may decide to just import the type from that one component: <code>import type {State} from ‘../some/component’</code> .</p>
<p>But this will slowly get out of hand.</p>
<p>My suggestion is to create a <code>types.js</code> file in the root of your app to keep reference .</p>
<p>This file should contain:</p>
<ul>
<li>Only app wide shared types (if its feature wide then create another types.js inside that feature folder).</li>
<li>Redux types like the InitialState for reducers etc.</li>
<li>Only flow types.</li>
</ul>
<h2>If you want an object to be immutable then you can type check it</h2><p>You really don’t want some component messing around with your state. So why not protect against it by declaring that object as immutable:</p>
<pre><code class="language-typescript">type AppConfig = {
 +apiKey: string // the &#39;+&#39; makes it immutable in Flow
};
const Settings: AppConfig = {
 apiKey: &#39;rihfwefiweufweiufgewfugew84r34t3&#39;
};
// later on....
Settings.apiKey = &#39;fiohwefoihefoihfoeihfewifhwfihefhwoef&#39;;</code></pre>
<p>Flow helps protect against the change by throwing this error:</p>
<pre><code class="language-markup">11: Settings.apiKey = &#39;fiohwefoihefoihfoeihfewifhwfihefhwoef&#39;;
    ^ object type. Covariant property `apiKey` incompatible with contravariant use in
11: Settings.apiKey = &#39;fiohwefoihefoihfoeihfewifhwfihefhwoef&#39;;
    ^ assignment of property `apiKey`</code></pre>
<h2>Read the documentation &amp; find references</h2><p>I can’t stress this enough how detailed the Flow docs are at explaining things. The most useful links I have found are as follows:</p>
<ol>
<li><a href="https://flow.org/en/docs/react/components/">Components | Flow</a></li>
<li><a href="https://flow.org/en/docs/react/redux/">Redux | Flow</a></li>
<li><a href="https://flow.org/en/docs/react/children/">Children | Flow</a></li>
<li><a href="https://flow.org/en/docs/lang/refinements/">Type Refinements | Flow</a></li>
<li><a href="https://www.saltycrane.com/flow-type-cheat-sheet/latest/#lib/dom.js">Flow DOM cheat sheet</a></li>
</ol>
  </main>
  <footer class="footer container">
    <p>&copy; 2018</p>
  </footer>
</body>
 
<script src="/js/vendor/prism.js"></script>  

</html>